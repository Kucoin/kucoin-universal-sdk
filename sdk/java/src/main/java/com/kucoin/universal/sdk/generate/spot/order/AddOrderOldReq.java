// Code generated by Kucoin Universal SDK Generator; DO NOT EDIT.

package com.kucoin.universal.sdk.generate.spot.order;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonValue;
import com.kucoin.universal.sdk.internal.interfaces.Request;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@AllArgsConstructor
@Builder
@Data
@NoArgsConstructor
@JsonIgnoreProperties(ignoreUnknown = true)
public class AddOrderOldReq implements Request {
  /**
   * Client Order Id，The ClientOid field is a unique ID created by the user（we recommend using a
   * UUID）, and can only contain numbers, letters, underscores （_）, and hyphens （-）. This field is
   * returned when order information is obtained. You can use clientOid to tag your orders.
   * ClientOid is different from the order ID created by the service provider. Please do not
   * initiate requests using the same clientOid. The maximum length for the ClientOid is 40
   * characters. Please remember the orderId created by the service provider, it used to check for
   * updates in order status.
   */
  @JsonProperty("clientOid")
  private String clientOid;

  /** specify if the order is to 'buy' or 'sell' */
  @JsonProperty("side")
  private SideEnum side;

  /** symbol */
  @JsonProperty("symbol")
  private String symbol;

  /**
   * specify if the order is an 'limit' order or 'market' order. The type of order you specify when
   * you place your order determines whether or not you need to request other parameters and also
   * affects the execution of the matching engine. When placing a limit order, you must specify a
   * price and size. The system will try to match the order according to market price or a price
   * better than market price. If the order cannot be immediately matched, it will stay in the order
   * book until it is matched or the user cancels. Unlike limit orders, the price for market orders
   * fluctuates with market prices. When placing a market order, you do not need to specify a price,
   * you only need to specify a quantity. Market orders are filled immediately and will not enter
   * the order book. All market orders are takers and a taker fee will be charged.
   */
  @JsonProperty("type")
  @Builder.Default
  private TypeEnum type = TypeEnum.LIMIT;

  /** Order placement remarks, length cannot exceed 20 characters (ASCII) */
  @JsonProperty("remark")
  private String remark;

  /**
   * [Self Trade Prevention](https://www.kucoin.com/docs-new/doc-338146) is divided into four
   * strategies: CN, CO, CB , and DC
   */
  @JsonProperty("stp")
  private StpEnum stp;

  /**
   * Specify price for order When placing a limit order, the price must be based on priceIncrement
   * for the trading pair. The price increment (priceIncrement) is the price precision for the
   * trading pair. For example, for the BTC-USDT trading pair, the priceIncrement is 0.00001000. So
   * the price for your orders cannot be less than 0.00001000 and must be a multiple of
   * priceIncrement. Otherwise, the order will return an invalid priceIncrement error.
   */
  @JsonProperty("price")
  private String price;

  /**
   * Specify quantity for order When **type** is limit, size refers to the amount of trading targets
   * (the asset name written in front) for the trading pair. Teh Size must be based on the
   * baseIncrement of the trading pair. The baseIncrement represents the precision for the trading
   * pair. The size of an order must be a positive-integer multiple of baseIncrement and must be
   * between baseMinSize and baseMaxSize. When **type** is market, select one out of two: size or
   * funds
   */
  @JsonProperty("size")
  private String size;

  /**
   * [Time in force](https://www.kucoin.com/docs-new/doc-338146) is a special strategy used during
   * trading
   */
  @JsonProperty("timeInForce")
  @Builder.Default
  private TimeInForceEnum timeInForce = TimeInForceEnum.GTC;

  /** passive order labels, this is disabled when the order timing strategy is IOC or FOK */
  @JsonProperty("postOnly")
  @Builder.Default
  private Boolean postOnly = false;

  /** Hidden or not (not shown in order book) */
  @JsonProperty("hidden")
  @Builder.Default
  private Boolean hidden = false;

  /** Whether or not only visible portions of orders are shown in iceberg orders */
  @JsonProperty("iceberg")
  @Builder.Default
  private Boolean iceberg = false;

  /** Maximum visible quantity in iceberg orders */
  @JsonProperty("visibleSize")
  private String visibleSize;

  /** Cancel after n seconds，the order timing strategy is GTT */
  @JsonProperty("cancelAfter")
  private Long cancelAfter;

  /** When **type** is market, select one out of two: size or funds */
  @JsonProperty("funds")
  private String funds;

  /**
   * The type of trading : **TRADE**（Spot Trade）, **MARGIN_TRADE** (Margin Trade). Default is
   * **TRADE**. **Note: To improve the system performance and to accelerate order placing and
   * processing, KuCoin has added a new interface for order placing of margin. For traders still
   * using the current interface, please move to the new one as soon as possible. The current one
   * will no longer accept margin orders by May 1st, 2021 (UTC). At the time, KuCoin will notify
   * users via the announcement, please pay attention to it.**
   */
  @JsonProperty("tradeType")
  @Builder.Default
  private TradeTypeEnum tradeType = TradeTypeEnum.TRADE;

  public enum SideEnum {
    /** */
    BUY("buy"),
    /** */
    SELL("sell");

    private final String value;

    SideEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static SideEnum fromValue(String value) {
      for (SideEnum b : SideEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public enum TypeEnum {
    /** limit order */
    LIMIT("limit"),
    /** market order */
    MARKET("market");

    private final String value;

    TypeEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static TypeEnum fromValue(String value) {
      for (TypeEnum b : TypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public enum StpEnum {
    /** */
    DC("DC"),
    /** */
    CO("CO"),
    /** */
    CN("CN"),
    /** */
    CB("CB");

    private final String value;

    StpEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static StpEnum fromValue(String value) {
      for (StpEnum b : StpEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public enum TimeInForceEnum {
    /** */
    GTC("GTC"),
    /** */
    GTT("GTT"),
    /** */
    IOC("IOC"),
    /** */
    FOK("FOK");

    private final String value;

    TimeInForceEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static TimeInForceEnum fromValue(String value) {
      for (TimeInForceEnum b : TimeInForceEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public enum TradeTypeEnum {
    /** Spot */
    TRADE("TRADE"),
    /** Margin */
    MARGIN_TRADE("MARGIN_TRADE");

    private final String value;

    TradeTypeEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static TradeTypeEnum fromValue(String value) {
      for (TradeTypeEnum b : TradeTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }
}
