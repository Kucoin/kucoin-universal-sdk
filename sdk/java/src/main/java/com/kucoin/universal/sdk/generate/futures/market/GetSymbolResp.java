// Code generated by Kucoin Universal SDK Generator; DO NOT EDIT.

package com.kucoin.universal.sdk.generate.futures.market;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonValue;
import com.kucoin.universal.sdk.internal.interfaces.Response;
import com.kucoin.universal.sdk.model.RestResponse;
import java.util.ArrayList;
import java.util.List;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@AllArgsConstructor
@Data
@NoArgsConstructor
@JsonIgnoreProperties(ignoreUnknown = true)
public class GetSymbolResp implements Response<GetSymbolResp, RestResponse<GetSymbolResp>> {
  /** Symbol */
  @JsonProperty("symbol")
  private String symbol;

  /** Contract group */
  @JsonProperty("rootSymbol")
  private String rootSymbol;

  /** Type of contract */
  @JsonProperty("type")
  private TypeEnum type;

  /** First Open Date (milliseconds) */
  @JsonProperty("firstOpenDate")
  private Long firstOpenDate;

  /** Expiration date (milliseconds) Null means it will never expire */
  @JsonProperty("expireDate")
  private Long expireDate;

  /** Settlement date (milliseconds) Null indicates that automatic settlement is not supported */
  @JsonProperty("settleDate")
  private Long settleDate;

  /** Base currency */
  @JsonProperty("baseCurrency")
  private String baseCurrency;

  /** Quote currency */
  @JsonProperty("quoteCurrency")
  private String quoteCurrency;

  /** Currency used to clear and settle the trades */
  @JsonProperty("settleCurrency")
  private String settleCurrency;

  /** Maximum order quantity */
  @JsonProperty("maxOrderQty")
  private Integer maxOrderQty;

  /** Maximum order price */
  @JsonProperty("maxPrice")
  private Double maxPrice;

  /** Minimum lot size */
  @JsonProperty("lotSize")
  private Integer lotSize;

  /** Minimum price changes */
  @JsonProperty("tickSize")
  private Double tickSize;

  /** Index price of tick size */
  @JsonProperty("indexPriceTickSize")
  private Double indexPriceTickSize;

  /**
   * The basic unit of the contract API is lots. For the number of coins in each lot, please refer
   * to the param multiplier. For example, for XBTUSDTM, multiplier=0.001, which corresponds to the
   * value of each XBTUSDTM contract being 0.001 BTC. There is also a special case. All coin-swap
   * contracts, such as each XBTUSDM contract, correspond to 1 USD.
   */
  @JsonProperty("multiplier")
  private Double multiplier;

  /** Initial margin requirement */
  @JsonProperty("initialMargin")
  private Double initialMargin;

  /** Maintenance margin requirement */
  @JsonProperty("maintainMargin")
  private Double maintainMargin;

  /** Maximum risk limit (unit: XBT) */
  @JsonProperty("maxRiskLimit")
  private Integer maxRiskLimit;

  /** Minimum risk limit (unit: XBT) */
  @JsonProperty("minRiskLimit")
  private Integer minRiskLimit;

  /** Risk limit increment value (unit: XBT) */
  @JsonProperty("riskStep")
  private Integer riskStep;

  /** Maker fee rate */
  @JsonProperty("makerFeeRate")
  private Double makerFeeRate;

  /** Taker fee rate */
  @JsonProperty("takerFeeRate")
  private Double takerFeeRate;

  /** Deprecated param */
  @JsonProperty("takerFixFee")
  private Double takerFixFee;

  /** Deprecated param */
  @JsonProperty("makerFixFee")
  private Double makerFixFee;

  /** Settlement fee */
  @JsonProperty("settlementFee")
  private Double settlementFee;

  /** Enabled ADL or not */
  @JsonProperty("isDeleverage")
  private Boolean isDeleverage;

  /** Deprecated param */
  @JsonProperty("isQuanto")
  private Boolean isQuanto;

  /** Whether it is a reverse contract */
  @JsonProperty("isInverse")
  private Boolean isInverse;

  /** Marking method */
  @JsonProperty("markMethod")
  private MarkMethodEnum markMethod;

  /** Fair price marking method; the Futures contract is null */
  @JsonProperty("fairMethod")
  private FairMethodEnum fairMethod;

  /** Ticker symbol of the base currency */
  @JsonProperty("fundingBaseSymbol")
  private String fundingBaseSymbol;

  /** Ticker symbol of the quote currency */
  @JsonProperty("fundingQuoteSymbol")
  private String fundingQuoteSymbol;

  /** Funding rate symbol */
  @JsonProperty("fundingRateSymbol")
  private String fundingRateSymbol;

  /** Index symbol */
  @JsonProperty("indexSymbol")
  private String indexSymbol;

  /** Settlement symbol */
  @JsonProperty("settlementSymbol")
  private String settlementSymbol;

  /** Contract status */
  @JsonProperty("status")
  private StatusEnum status;

  /** Funding fee rate */
  @JsonProperty("fundingFeeRate")
  private Double fundingFeeRate;

  /** Predicted funding fee rate */
  @JsonProperty("predictedFundingFeeRate")
  private Double predictedFundingFeeRate;

  /** Funding interval (milliseconds) */
  @JsonProperty("fundingRateGranularity")
  private Integer fundingRateGranularity;

  /** Open interest (unit: lots) */
  @JsonProperty("openInterest")
  private String openInterest;

  /** 24-hour turnover */
  @JsonProperty("turnoverOf24h")
  private Double turnoverOf24h;

  /** 24-hour volume */
  @JsonProperty("volumeOf24h")
  private Double volumeOf24h;

  /** Mark price */
  @JsonProperty("markPrice")
  private Double markPrice;

  /** Index price */
  @JsonProperty("indexPrice")
  private Double indexPrice;

  /** Last trade price */
  @JsonProperty("lastTradePrice")
  private Double lastTradePrice;

  /** Next funding rate time (milliseconds) */
  @JsonProperty("nextFundingRateTime")
  private Integer nextFundingRateTime;

  /** Maximum leverage */
  @JsonProperty("maxLeverage")
  private Integer maxLeverage;

  /** The contract index price source exchange */
  @JsonProperty("sourceExchanges")
  private List<String> sourceExchanges = new ArrayList<>();

  /** Premium index symbol (1 minute) */
  @JsonProperty("premiumsSymbol1M")
  private String premiumsSymbol1M;

  /** Premium index symbol (8 hours) */
  @JsonProperty("premiumsSymbol8H")
  private String premiumsSymbol8H;

  /** Base currency interest rate symbol (1 minute) */
  @JsonProperty("fundingBaseSymbol1M")
  private String fundingBaseSymbol1M;

  /** Quote currency interest rate symbol (1 minute) */
  @JsonProperty("fundingQuoteSymbol1M")
  private String fundingQuoteSymbol1M;

  /** 24-hour lowest price */
  @JsonProperty("lowPrice")
  private Double lowPrice;

  /** 24-hour highest price */
  @JsonProperty("highPrice")
  private Double highPrice;

  /** 24-hour % price change */
  @JsonProperty("priceChgPct")
  private Double priceChgPct;

  /** 24-hour price change */
  @JsonProperty("priceChg")
  private Double priceChg;

  /** */
  @JsonProperty("k")
  private Double k;

  /** */
  @JsonProperty("m")
  private Double m;

  /** */
  @JsonProperty("f")
  private Double f;

  /** */
  @JsonProperty("mmrLimit")
  private Double mmrLimit;

  /** */
  @JsonProperty("mmrLevConstant")
  private Double mmrLevConstant;

  /** Whether support Cross Margin */
  @JsonProperty("supportCross")
  private Boolean supportCross;

  /** The current maximum buying price allowed */
  @JsonProperty("buyLimit")
  private Double buyLimit;

  /** The current minimum selling price allowed */
  @JsonProperty("sellLimit")
  private Double sellLimit;

  /** common response */
  @JsonIgnore private RestResponse<GetSymbolResp> commonResponse;

  @Override
  public void setCommonResponse(RestResponse<GetSymbolResp> response) {
    this.commonResponse = response;
  }

  public enum TypeEnum {
    /**
     * Standardized swap contracts, standard financial futures on swaps, expiration swap funding
     * rates
     */
    FFWCSX("FFWCSX"),
    /** Futures Contract */
    FFICSX("FFICSX");

    private final String value;

    TypeEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static TypeEnum fromValue(String value) {
      for (TypeEnum b : TypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public enum MarkMethodEnum {
    /** FairPrice */
    FAIRPRICE("FairPrice");

    private final String value;

    MarkMethodEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static MarkMethodEnum fromValue(String value) {
      for (MarkMethodEnum b : MarkMethodEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public enum FairMethodEnum {
    /** FundingRate */
    FUNDINGRATE("FundingRate");

    private final String value;

    FairMethodEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static FairMethodEnum fromValue(String value) {
      for (FairMethodEnum b : FairMethodEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public enum StatusEnum {
    /** Initial */
    INIT("Init"),
    /** Online */
    OPEN("Open"),
    /** Settling */
    BEINGSETTLED("BeingSettled"),
    /** Settled */
    SETTLED("Settled"),
    /** Suspended */
    PAUSED("Paused"),
    /** Offline */
    CLOSED("Closed"),
    /** Orders can only be canceled */
    CANCELONLY("CancelOnly");

    private final String value;

    StatusEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static StatusEnum fromValue(String value) {
      for (StatusEnum b : StatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }
}
