// Code generated by Kucoin Universal SDK Generator; DO NOT EDIT.

package com.kucoin.universal.sdk.generate.futures.futuresprivate;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonValue;
import com.kucoin.universal.sdk.internal.interfaces.Response;
import com.kucoin.universal.sdk.internal.interfaces.WebSocketMessageCallback;
import com.kucoin.universal.sdk.model.WsMessage;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@AllArgsConstructor
@Data
@NoArgsConstructor
@JsonIgnoreProperties(ignoreUnknown = true)
public class PositionEvent implements Response<PositionEvent, WsMessage> {
  /**
   * Symbol of the contract. Please refer to [Get Symbol endpoint:
   * symbol](https://www.kucoin.com/docs-new/api-221752070)
   */
  @JsonProperty("symbol")
  private String symbol;

  /** Whether it is cross margin. */
  @JsonProperty("crossMode")
  private Boolean crossMode;

  /** ADL ranking percentile */
  @JsonProperty("delevPercentage")
  private Double delevPercentage;

  /** Open time */
  @JsonProperty("openingTimestamp")
  private Long openingTimestamp;

  /** Current timestamp */
  @JsonProperty("currentTimestamp")
  private Long currentTimestamp;

  /** Current position quantity */
  @JsonProperty("currentQty")
  private Integer currentQty;

  /** Current position value */
  @JsonProperty("currentCost")
  private Double currentCost;

  /** Current commission */
  @JsonProperty("currentComm")
  private Double currentComm;

  /** Unrealized value */
  @JsonProperty("unrealisedCost")
  private Double unrealisedCost;

  /** Accumulated realized gross profit value */
  @JsonProperty("realisedGrossCost")
  private Double realisedGrossCost;

  /** Current realized position value */
  @JsonProperty("realisedCost")
  private Double realisedCost;

  /** Opened position or not */
  @JsonProperty("isOpen")
  private Boolean isOpen;

  /** Mark price */
  @JsonProperty("markPrice")
  private Double markPrice;

  /** Mark Value */
  @JsonProperty("markValue")
  private Double markValue;

  /** Position value */
  @JsonProperty("posCost")
  private Double posCost;

  /**
   * Inital margin Cross = opening value/cross leverage; isolated = accumulation of initial margin
   * for each transaction
   */
  @JsonProperty("posInit")
  private Double posInit;

  /**
   * Bankruptcy cost Cross = mark value * imr; Isolated = position margin (accumulation of initial
   * margin, additional margin, generated funding fees, etc.)
   */
  @JsonProperty("posMargin")
  private Double posMargin;

  /** Accumulated realized gross profit value */
  @JsonProperty("realisedGrossPnl")
  private Double realisedGrossPnl;

  /** Realized profit and loss */
  @JsonProperty("realisedPnl")
  private Double realisedPnl;

  /** Unrealized profit and loss */
  @JsonProperty("unrealisedPnl")
  private Double unrealisedPnl;

  /** Profit-loss ratio of the position */
  @JsonProperty("unrealisedPnlPcnt")
  private Double unrealisedPnlPcnt;

  /** Rate of return on investment */
  @JsonProperty("unrealisedRoePcnt")
  private Double unrealisedRoePcnt;

  /** Average entry price */
  @JsonProperty("avgEntryPrice")
  private Double avgEntryPrice;

  /**
   * Liquidation price: For Cross Margin, you can refer to the liquidationPrice, and the liquidation
   * is based on the risk rate.
   */
  @JsonProperty("liquidationPrice")
  private Double liquidationPrice;

  /**
   * Bankruptcy price: For Cross Margin, you can refer to the bankruptPrice, and the liquidation is
   * based on the risk rate.
   */
  @JsonProperty("bankruptPrice")
  private Double bankruptPrice;

  /** Currency used to clear and settle the trades */
  @JsonProperty("settleCurrency")
  private String settleCurrency;

  /** Margin Mode: CROSS, ISOLATED */
  @JsonProperty("marginMode")
  private MarginModeEnum marginMode;

  /** Position Side */
  @JsonProperty("positionSide")
  private PositionSideEnum positionSide;

  /** Leverage */
  @JsonProperty("leverage")
  private Double leverage;

  /** Auto deposit margin or not **Only applicable to Isolated Margin** */
  @JsonProperty("autoDeposit")
  private Boolean autoDeposit;

  /** Maintenance margin requirement */
  @JsonProperty("maintMarginReq")
  private Double maintMarginReq;

  /** Risk limit **Only applicable to Isolated Margin** */
  @JsonProperty("riskLimit")
  private Integer riskLimit;

  /** Leverage of the order **Only applicable to Isolated Margin** */
  @JsonProperty("realLeverage")
  private Double realLeverage;

  /** Added margin **Only applicable to Isolated Margin** */
  @JsonProperty("posCross")
  private Double posCross;

  /** Bankruptcy cost **Only applicable to Isolated Margin** */
  @JsonProperty("posComm")
  private Double posComm;

  /** Funding fees paid out **Only applicable to Isolated Margin** */
  @JsonProperty("posLoss")
  private Double posLoss;

  /**
   * The current remaining unsettled funding fee for the position **Only applicable to Isolated
   * Margin**
   */
  @JsonProperty("posFunding")
  private Double posFunding;

  /** Maintenance margin */
  @JsonProperty("posMaint")
  private Double posMaint;

  /** Position margin **Only applicable to Isolated Margin** */
  @JsonProperty("maintMargin")
  private Double maintMargin;

  /** Funding time */
  @JsonProperty("fundingTime")
  private Long fundingTime;

  /** Position size */
  @JsonProperty("qty")
  private Integer qty;

  /** Funding rate */
  @JsonProperty("fundingRate")
  private Double fundingRate;

  /** Funding fees */
  @JsonProperty("fundingFee")
  private Double fundingFee;

  /** Funding Fee Settlement Time (nanoseconds) */
  @JsonProperty("ts")
  private Long ts;

  /** Adjustment isolated margin risk limit level successful or not */
  @JsonProperty("success")
  private Boolean success;

  /** Adjustment isolated margin risk limit level failure reason */
  @JsonProperty("msg")
  private String msg;

  /** common response */
  @JsonIgnore private WsMessage commonResponse;

  @Override
  public void setCommonResponse(WsMessage response) {
    this.commonResponse = response;
  }

  @FunctionalInterface
  public interface Callback {
    void onEvent(String topic, String subject, PositionEvent data);
  }

  public static class CallbackAdapters {
    public static WebSocketMessageCallback<PositionEvent> of(Callback callback) {
      return (msg, objectMapper) ->
          callback.onEvent(
              msg.getTopic(),
              msg.getSubject(),
              objectMapper.convertValue(msg.getData(), PositionEvent.class));
    }
  }

  public enum MarginModeEnum {
    /** cross margin */
    CROSS("CROSS"),
    /** isolated margin */
    ISOLATED("ISOLATED");

    private final String value;

    MarginModeEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static MarginModeEnum fromValue(String value) {
      for (MarginModeEnum b : MarginModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public enum PositionSideEnum {
    /** One-way position */
    BOTH("BOTH");

    private final String value;

    PositionSideEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static PositionSideEnum fromValue(String value) {
      for (PositionSideEnum b : PositionSideEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }
}
