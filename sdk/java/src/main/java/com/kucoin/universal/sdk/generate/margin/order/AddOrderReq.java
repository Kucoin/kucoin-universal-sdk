// Code generated by Kucoin Universal SDK Generator; DO NOT EDIT.

package com.kucoin.universal.sdk.generate.margin.order;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonValue;
import com.kucoin.universal.sdk.internal.interfaces.Request;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@AllArgsConstructor
@Builder
@Data
@NoArgsConstructor
@JsonIgnoreProperties(ignoreUnknown = true)
public class AddOrderReq implements Request {
  /**
   * Client Order ID: The ClientOid field is a unique ID created by the user (we recommend using a
   * UUID), and can only contain numbers, letters, underscores (_), and hyphens (-). This field is
   * returned when order information is obtained. You can use clientOid to tag your orders.
   * ClientOid is different from the order ID created by the service provider. Please do not
   * initiate requests using the same clientOid. The maximum length for the ClientOid is 40
   * characters. Please remember the orderId created by the service provider, it used to check for
   * updates in order status.
   */
  @JsonProperty("clientOid")
  private String clientOid;

  /** Specify if the order is to 'buy' or 'sell'. */
  @JsonProperty("side")
  private SideEnum side;

  /** symbol */
  @JsonProperty("symbol")
  private String symbol;

  /**
   * Specify if the order is a 'limit' order or 'market' order. The type of order you specify when
   * you place your order determines whether or not you need to request other parameters and also
   * affects the execution of the matching engine. When placing a limit order, you must specify a
   * price and size. The system will try to match the order according to market price or a price
   * better than market price. If the order cannot be immediately matched, it will stay in the order
   * book until it is matched or the user cancels. Unlike limit orders, the price for market orders
   * fluctuates with market prices. When placing a market order, you do not need to specify a price;
   * you only need to specify a quantity. Market orders are filled immediately and will not enter
   * the order book. All market orders are takers and a taker fee will be charged.
   */
  @JsonProperty("type")
  @Builder.Default
  private TypeEnum type = TypeEnum.LIMIT;

  /**
   * [Self Trade Prevention](https://www.kucoin.com/docs-new/doc-338146) is divided into these
   * strategies: CN, CO, CB , and DC
   */
  @JsonProperty("stp")
  private StpEnum stp;

  /**
   * Specify price for order When placing a limit order, the price must be based on priceIncrement
   * for the trading pair. The price increment (priceIncrement) is the price precision for the
   * trading pair. For example, for the BTC-USDT trading pair, the priceIncrement is 0.00001000. So
   * the price for your orders cannot be less than 0.00001000 and must be a multiple of
   * priceIncrement. Otherwise, the order will return an invalid priceIncrement error.
   */
  @JsonProperty("price")
  private String price;

  /**
   * Specify quantity for order. When **type** is limited, size refers to the amount of trading
   * targets (the asset name written in front) for the trading pair. The Size must be based on the
   * baseIncrement of the trading pair. The baseIncrement represents the precision for the trading
   * pair. The size of an order must be a positive-integer multiple of baseIncrement and must be
   * between baseMinSize and baseMaxSize. When **type** is market, select one out of two: size or
   * funds
   */
  @JsonProperty("size")
  private String size;

  /**
   * [Time in force](https://www.kucoin.com/docs-new/api-5176570) is a special strategy used during
   * trading
   */
  @JsonProperty("timeInForce")
  @Builder.Default
  private TimeInForceEnum timeInForce = TimeInForceEnum.GTC;

  /** passive order labels, this is disabled when the order timing strategy is IOC or FOK */
  @JsonProperty("postOnly")
  @Builder.Default
  private Boolean postOnly = false;

  /** [Hidden order](https://www.kucoin.com/docs-new/doc-338146) or not (not shown in order book) */
  @JsonProperty("hidden")
  @Builder.Default
  private Boolean hidden = false;

  /**
   * Whether or not only visible portions of orders are shown in [Iceberg
   * orders](https://www.kucoin.com/docs-new/doc-338146)
   */
  @JsonProperty("iceberg")
  @Builder.Default
  private Boolean iceberg = false;

  /** Maximum visible quantity in iceberg orders */
  @JsonProperty("visibleSize")
  private String visibleSize;

  /** Cancel after n seconds, the order timing strategy is GTT */
  @JsonProperty("cancelAfter")
  private Long cancelAfter;

  /** When **type** is market, select one out of two: size or funds */
  @JsonProperty("funds")
  private String funds;

  /** True - isolated margin; false - cross margin. Default is false */
  @JsonProperty("isIsolated")
  @Builder.Default
  private Boolean isIsolated = false;

  /**
   * When Margin Account has inefficient balance, our system autoborrows inefficient assets and
   * opens positions according to the lowest market interest rate.
   */
  @JsonProperty("autoBorrow")
  @Builder.Default
  private Boolean autoBorrow = false;

  /**
   * AutoPay allows the return of borrowed assets when you close a position. Our system
   * automatically triggers the repayment and the maximum repayment amount equals to the
   * filled-order amount.
   */
  @JsonProperty("autoRepay")
  @Builder.Default
  private Boolean autoRepay = false;

  public enum SideEnum {
    /** */
    BUY("buy"),
    /** */
    SELL("sell");

    private final String value;

    SideEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static SideEnum fromValue(String value) {
      for (SideEnum b : SideEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public enum TypeEnum {
    /** */
    LIMIT("limit"),
    /** */
    MARKET("market");

    private final String value;

    TypeEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static TypeEnum fromValue(String value) {
      for (TypeEnum b : TypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public enum StpEnum {
    /** */
    DC("DC"),
    /** */
    CO("CO"),
    /** */
    CN("CN"),
    /** */
    CB("CB");

    private final String value;

    StpEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static StpEnum fromValue(String value) {
      for (StpEnum b : StpEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public enum TimeInForceEnum {
    /** */
    GTC("GTC"),
    /** */
    GTT("GTT"),
    /** */
    IOC("IOC"),
    /** */
    FOK("FOK");

    private final String value;

    TimeInForceEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static TimeInForceEnum fromValue(String value) {
      for (TimeInForceEnum b : TimeInForceEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }
}
