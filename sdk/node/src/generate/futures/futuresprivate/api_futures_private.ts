// Code generated by Kucoin Universal SDK Generator; DO NOT EDIT.

import { MarginModeEventCallbackWrapper, MarginModeEventCallback } from './model_margin_mode_event';
import { BalanceEventCallbackWrapper, BalanceEventCallback } from './model_balance_event';
import { PositionEventCallbackWrapper, PositionEventCallback } from './model_position_event';
import { StopOrdersEventCallback, StopOrdersEventCallbackWrapper } from './model_stop_orders_event';
import {
    CrossLeverageEventCallback,
    CrossLeverageEventCallbackWrapper,
} from './model_cross_leverage_event';
import {
    AllPositionEventCallback,
    AllPositionEventCallbackWrapper,
} from './model_all_position_event';
import { OrderEventCallbackWrapper, OrderEventCallback } from './model_order_event';
import { AllOrderEventCallback, AllOrderEventCallbackWrapper } from './model_all_order_event';
import { WebSocketService } from '@internal/interfaces/websocket';

export interface FuturesPrivateWS {
    /**
     * allOrder All Order change pushes.
     * Push order changes for all symbol
     * push frequency: real-time
     */
    allOrder(callback: AllOrderEventCallback): Promise<string>;

    /**
     * allPosition All symbol position change events push
     * Subscribe to this topic to get real-time pushes on all symbols’ position change events
     * push frequency: real-time
     */
    allPosition(callback: AllPositionEventCallback): Promise<string>;

    /**
     * balance the balance change push
     * Subscribe to this topic to get real-time balance change pushes
     * push frequency: real-time
     */
    balance(callback: BalanceEventCallback): Promise<string>;

    /**
     * crossLeverage the leverage change push
     * Subscribe to this topic to get real-time pushes on leverage changes of contracts that are in cross margin mode
     * push frequency: real-time
     */
    crossLeverage(callback: CrossLeverageEventCallback): Promise<string>;

    /**
     * marginMode the margin mode change
     * Subscribe to this topic to get real-time pushes on symbols’ margin mode change events
     * push frequency: real-time
     */
    marginMode(callback: MarginModeEventCallback): Promise<string>;

    /**
     * order Order change pushes.
     * Push order changes for the specified symbol
     * push frequency: real-time
     */
    order(symbol: string, callback: OrderEventCallback): Promise<string>;

    /**
     * position the position change events push
     * Subscribe this topic to get real-time pushes on symbols’ position change events
     * push frequency: real-time
     */
    position(symbol: string, callback: PositionEventCallback): Promise<string>;

    /**
     * stopOrders stop order change pushes.
     * Subscribe to this topic to get real-time pushes on stop order changes.
     * push frequency: real-time
     */
    stopOrders(callback: StopOrdersEventCallback): Promise<string>;

    /**
     * Unsubscribe from topics
     */
    unSubscribe(id: string): Promise<void>;

    /**
     * Start websocket
     */
    start(): Promise<void>;

    /**
     * Stop websocket
     */
    stop(): Promise<void>;
}

export class FuturesPrivateWSImpl implements FuturesPrivateWS {
    private wsService: WebSocketService;

    constructor(wsService: WebSocketService) {
        this.wsService = wsService;
    }

    allOrder(callback: AllOrderEventCallback): Promise<string> {
        let topicPrefix = '/contractMarket/tradeOrders';

        let args: string[] = [];

        return this.wsService.subscribe(
            topicPrefix,
            args,
            new AllOrderEventCallbackWrapper(callback),
        );
    }

    allPosition(callback: AllPositionEventCallback): Promise<string> {
        let topicPrefix = '/contract/positionAll';

        let args: string[] = [];

        return this.wsService.subscribe(
            topicPrefix,
            args,
            new AllPositionEventCallbackWrapper(callback),
        );
    }

    balance(callback: BalanceEventCallback): Promise<string> {
        let topicPrefix = '/contractAccount/wallet';

        let args: string[] = [];

        return this.wsService.subscribe(
            topicPrefix,
            args,
            new BalanceEventCallbackWrapper(callback),
        );
    }

    crossLeverage(callback: CrossLeverageEventCallback): Promise<string> {
        let topicPrefix = '/contract/crossLeverage';

        let args: string[] = [];

        return this.wsService.subscribe(
            topicPrefix,
            args,
            new CrossLeverageEventCallbackWrapper(callback),
        );
    }

    marginMode(callback: MarginModeEventCallback): Promise<string> {
        let topicPrefix = '/contract/marginMode';

        let args: string[] = [];

        return this.wsService.subscribe(
            topicPrefix,
            args,
            new MarginModeEventCallbackWrapper(callback),
        );
    }

    order(symbol: string, callback: OrderEventCallback): Promise<string> {
        let topicPrefix = '/contractMarket/tradeOrders';

        let args: string[] = [symbol];

        return this.wsService.subscribe(topicPrefix, args, new OrderEventCallbackWrapper(callback));
    }

    position(symbol: string, callback: PositionEventCallback): Promise<string> {
        let topicPrefix = '/contract/position';

        let args: string[] = [symbol];

        return this.wsService.subscribe(
            topicPrefix,
            args,
            new PositionEventCallbackWrapper(callback),
        );
    }

    stopOrders(callback: StopOrdersEventCallback): Promise<string> {
        let topicPrefix = '/contractMarket/advancedOrders';

        let args: string[] = [];

        return this.wsService.subscribe(
            topicPrefix,
            args,
            new StopOrdersEventCallbackWrapper(callback),
        );
    }

    unSubscribe(id: string): Promise<void> {
        return this.wsService.unsubscribe(id);
    }

    start(): Promise<void> {
        return this.wsService.start();
    }

    stop(): Promise<void> {
        return this.wsService.stop();
    }
}
